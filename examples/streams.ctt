module streams where

import prelude
import nat


-- Datatypes:
data gStr (A : U) k
  = Cons (x : A) (xs : |> k (gStr A $ k))

Str (A : U) : U
  = forall k, gStr A $ k


-- Basic operations:
ghd (A : U) k : (xs : gStr A $ k) -> A
  = split
      Cons x _ -> x

gtl (A : U) k : (xs : gStr A $ k) -> |> k (gStr A $ k)
  = split
      Cons _ ys -> ys

hd (A : U) (xs : Str A) : A
  = ghd A $ k0 (xs $ k0)

tl (A : U) (xs : Str A) : Str A
  = prev k (gtl A $ k (xs $ k))

nth (A : U) (xs : Str A) : (n : nat) -> A
  = split
    zero  -> hd A xs
    suc n -> nth A (tl A xs) n
    
-- Simple examples of streams:
zeros : Str nat
  = [ k ] fix k zeros (gStr nat $ k) (Cons zero zeros)

zeros' : Str nat
  = [ k ] fix k zeros' (gStr nat $ k) (Cons zero (next k (Cons zero zeros')))

proof k : Id (gStr nat $ k) (zeros $ k) (zeros' $ k)
  = fix k (<i>
     Cons zero (next k [ (x' : gStr nat $ k) <- gtl nat $ k (zeros' $ k) ]
                       (Cons zero (next k [ p' <- proof ] (p' @ i) [ (i=0) -> gtl nat $ k (zeros $ k), (i=1) -> gtl nat $ k x' ] ))
                       [ (i = 0) -> gtl nat $ k (zeros $ k), (i=1) -> gtl nat $ k (zeros' $ k)]))

nats : Str nat
  = [ k ] nats' $ k zero
    where
      nats' k : (n : nat) -> gStr nat $ k
        = fix k nats' ((n : nat) -> gStr nat $ k)
            (\ (n : nat) ->
              Cons n (next k [ f <- nats' ] (f (suc n)) []))


-- Common stream operations:
gmap (A B : U) k (f : A -> B) : gStr A $ k -> gStr B $ k
  = fix k gmap (gStr A $ k -> gStr B $ k)
      (\ (xs : gStr A $ k) ->
        Cons (f (ghd A $ k xs))
	  (next k [ g <- gmap , ys <- gtl A $ k xs ]
	    (g ys) []))

map (A B : U) (f : A -> B) (xs : Str A) : Str B
  = [ k ] gmap A B $ k f (xs $ k)

ginterleave (A : U) k : gStr A $ k -> |> k (gStr A $ k) -> gStr A $ k
  = fix k ginterleave (gStr A $ k -> |> k (gStr A $ k) -> gStr A $ k)
    (\ (xs : gStr A $ k) (ys : |> k (gStr A $ k)) ->
      Cons (ghd A $ k xs)
        (next k [ g <- ginterleave, ys' <- ys, xs' <- gtl A $ k xs]
	  (g ys' (next k xs')) []))

interleave (A : U) (xs ys : Str A) : Str A
  = [ k ] ginterleave A $ k (xs $ k) (next k (ys $ k))


-- More stream examples:
ones : Str nat
  = map nat nat (add one) zeros

toggle : Str nat -- 1,0,1,0,...
  = interleave nat ones zeros

paperfolds : Str nat -- the regular paperfolding sequence
  = [ k ] fix k paperfolds (gStr nat $ k)
    ginterleave nat $ k (toggle $ k) paperfolds

evens : Str nat -- evens = 0 :: map plustwo evens
  = [ k ] fix k evens (gStr nat $ k)
      (Cons zero
        (next k [evens' <- evens]
         (gmap nat nat $ k (add two) evens') []))

odds : Str nat
  = map nat nat (add one) evens

-- An example of a proof using Löb induction:

-- We want to show that the interleaving of evens and odds yields the
-- stream of natural numbers:
--
-- Id (Str nat) nats (interleave nat evens odds)
--
-- First we will show:
--
-- ∀(n:ℕ). iterate (add one) n
--        = interleave (iterate (add two) n) (iterate (add two) (succ n))

iterate k (f : nat -> nat) : nat -> gStr nat $ k
  = fix k it (nat -> gStr nat $ k)
    (\ (n : nat) ->
      Cons n (next k [it' <- it] (it' (f n)) []))


plusone (n : nat) : nat = suc n
plustwo (n : nat) : nat = suc (suc n)

lemma1 k : (n : nat) -> Id (gStr nat $ k)
  (iterate $ k plusone n)
  (ginterleave nat $ k (iterate $ k plustwo n) (next k (iterate $ k plustwo (suc n))))
  = fix k
    (\ (n:nat) ->
       <i> Cons n
         (next k [l <- lemma1] (l (suc n) @ i)
	   [(i=0) -> gtl nat $ k (iterate $ k plusone n)
	   ,(i=1) -> gtl nat $ k (ginterleave nat $ k (iterate $ k plustwo n) (next k (iterate $ k plustwo (suc n))))]))
