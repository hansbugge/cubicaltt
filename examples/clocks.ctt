module clocks where


later k :|> k U -> U
  = (\ (A : |> k U) -> |> k [ (a : U) <- A ] a)

app (A : U) (B : A -> U) : forall k, (F : |> k ((x : A) -> B x)) (X : |> k A) -> |> k [ (x : A) <- X ] (B x)
  = [ k ] \ (F : |> k ((x : A) -> B x)) (X : |> k A) -> next k [ (x : A) <- X, (f : ((x : A) -> B x)) <- F ] (f x) []

app' (A : U) (B : U) : forall k, (F : |> k ((x : A) -> B)) (X : |> k A) -> |> k B
  = app A (\ (_ : A) -> B)

fix' (A : U) : forall k, (|> k A -> A) -> A
  = [ k ] (\ (f : |> k A -> A) -> f (dfix k A f))

data Unit = unit

fl (t : forall k, U) : U
 = forall k, t $ k

StreamF (A : U) k (Stream : |> k U) : U
  = ((a : A) * later $ k Stream)

Stream (A : U) k : U
  = fix k Stream U (StreamF A $ k Stream)


dfixeq (A : U) : forall k, (f : |> k A -> A) -> IdP (<i> |> k A) (next k (f (dfix k A f))) (dfix k A f)
   = [ k ] \ (f : |> k A -> A) ->
     <i> next k [] (f (dfix k A f))
                   [ (i=0) -> (next k (f (dfix k A f))),
		     (i=1) -> (dfix k A f) ]

dfixeq' (A : U) k (f : |> k A -> A) : IdP (<_> |> k A) (next k (fix k phi A (f phi))) (dfix k A f)
  =  <i> next k [] (f (dfix k A f))
                   [ (i=0) -> (next k (f (dfix k A f))),
		     (i=1) -> (dfix k A f) ]

fold : forall k, (f : |> k U -> U) -> |> k (fix' U $ k f) -> later $ k (dfix k U f)
 = [ k ] \ (f : |> k U -> U) (x : |> k (fix' U $ k f)) -> transport (<i> later $ k (dfixeq U $ k f @ i)) x

unfold : forall k, (f : |> k U -> U) -> later $ k (dfix k U f) -> |> k (fix' U $ k f)
 = [ k ] \ (f : |> k U -> U) (x : later $ k (dfix k U f)) -> transport (<i> later $ k (dfixeq U $ k f @ -i)) x

-- dfixeq (A : U) : forall k, (f : |> k A -> A) -> IdP (<i> |> k A) (next k (f (dfix k A f))) (dfix k A f)
--    = [ k ] \ (f : |> k A -> A) -> <i> next k [] (f (dfix k A f)) [ (i=0) -> (next k (f (dfix k A f))), (i=1) -> (dfix k A f) ]

ifold (A : U) : forall k, (f : |> k (A -> U) -> A -> U) -> (x : A) 
                          -> |> k (fix' (A -> U) $ k f x) 
                          -> later $ k (next k [ (f' : A -> U) <- (dfix k (A -> U) f) ] (f' x) [])
 = [ k ] \ (f : |> k (A -> U) -> (A -> U)) (x : A) (y : |> k (fix' (A -> U) $ k f x)) -> transport 
          (<i> later $ k (next k [ (f' : A -> U) <- (dfixeq (A -> U) $ k f @ i) ] (f' x) [])) y 

ifold2 (A : U) : forall k, (f : |> k (A -> U) -> A -> U) -> (x : |> k A)
                          -> later $ k (next k [ (x' : A) <- x ] (fix' (A -> U) $ k f x') [])
                          -> later $ k (app' A U $ k (dfix k (A -> U) f) x)
 = [ k ] \ (f : |> k (A -> U) -> (A -> U)) (x : |> k A) (y : later $ k (next k [ (x' : A) <- x ] (fix' (A -> U) $ k f x') []) ) -> 
      transport (<i> later $ k (app' A U $ k (dfixeq (A -> U) $ k f @ i) x)) y

iunfold (A : U) : forall k, (f : |> k (A -> U) -> A -> U) -> (x : A)
                          -> later $ k (next k [ (f' : A -> U) <- (dfix k (A -> U) f) ] (f' x) [])
                          -> |> k (fix' (A -> U) $ k f x)
 = [ k ] \ (f : |> k (A -> U) -> (A -> U)) (x : A) (y : later $ k (next k [ (f' : A -> U) <- (dfix k (A -> U) f) ] (f' x) [])) -> transport 
          (<i> later $ k (next k [ (f' : A -> U) <- (dfixeq (A -> U) $ k f @ -i) ] (f' x) [])) y

 -- transport (<i> later $ k (dfixeq (A -> U) $ k f @ i)) x

-- unifold : forall k, (f : |> k U -> U) -> later $ k (dfix k U f) -> |> k (fix' U $ k f)
--  = [ k ] \ (f : |> k U -> U) (x : later $ k (dfix k U f)) -> transport (<i> later $ k (dfixeq U $ k f @ -i)) x

unfoldfold : forall k, (f : |> k U -> U) (x : |> k (fix' U $ k f)) -> IdP (<i> |> k (fix' U $ k f)) x (unfold $ k f (fold $ k f x))
  = undefined -- [ k ] \ (f : |> k U -> U) (x : |> k (fix' U $ k f)) -> ?

ghd (A : U) : forall k, (Stream A $ k) -> A
  = [ k ] (\ (x : Stream A $ k) -> x.1)

gtl (A : U) : forall k, (Stream A $ k) -> |> k (Stream A $ k)
  = [ k ] (\ (x : Stream A $ k) -> unfold $ k (StreamF A $ k) (x.2))

tail (A : U) (xs : forall k, (Stream A $ k)) : (forall k, (Stream A $ k))
  = prev k (gtl A $ k (xs $ k))

head (A : U) (xs : forall k, Stream A $ k) : forall k, A
  = [ k ] ghd A $ k (xs $ k)

units : forall k, Stream Unit $ k
  = [ k ] fix k units (Stream Unit $ k) (unit , fold $ k (StreamF Unit $ k) units )

snd : forall k, Unit
 = head Unit (tail Unit (tail Unit units))

trd : forall k, Unit
 = head Unit (tail Unit (tail Unit (tail Unit units)))

liftP (A : U) (P : A -> U) : forall k, Stream A $ k -> U
 = [ k ] fix k liftP (Stream A $ k -> U) (
             \ (xs : Stream A $ k) -> (_ : P (ghd A $ k xs)) *
              later $ k (app' (Stream A $ k) U $ k liftP (gtl A $ k xs)))

-- liftLemma (A : U) (P : A -> U) (p : (x : A) -> P x) : forall k, (xs : Stream A $ k) -> liftP A P $ k xs
--   = [ k ] fix' ((xs : Stream A $ k) -> liftP A P $ k xs) $ k 
--            (\ (phi : |> k ((xs : Stream A $ k) -> liftP A P $ k xs)) (xs : Stream A $ k) -> 
--      (p (ghd A $ k xs) , 
--  ifold (Stream A $ k) $ k  ? (app (Stream A $ k) (\ (xs : Stream A $ k) -> liftP A P $ k xs)$ k phi (gtl A $ k xs)))) 

-- ifold (Stream A $ k) $ k ? ?



