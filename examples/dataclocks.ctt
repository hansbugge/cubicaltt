module dataclocks where

import prelude

fix' (A : U) : forall k, (|> k A -> A) -> A
  = [ k ] (\ (f : |> k A -> A) -> f (dfix k A f))

app (A : U) (B : A -> U) : forall k, (F : |> k ((x : A) -> B x)) (X : |> k A) -> |> k [ x <- X ] (B x)
 = [ k ] \ (F : |> k ((x : A) -> B x)) (X : |> k A) -> next k [ x <- X, f <- F ] (f x) []

app' (A : U) (B : U) k (F : |> k ((x : A) -> B)) (X : |> k A) : |> k B
 = next k [ x <- app A (\ (_ : A) -> B) $ k F X ] x []

dfixeq (A : U) : forall k, (f : |> k A -> A) -> IdP (<i> |> k A) (next k (f (dfix k A f))) (dfix k A f)
   = [ k ] \ (f : |> k A -> A) -> <i> next k [] (f (dfix k A f)) [ (i=0) -> (next k (f (dfix k A f))), (i=1) -> (dfix k A f) ]

data gStr (A : U) k = Cons (x : A) (xs : |> k (gStr A $ k))

uncons (A : U) k (P : gStr A $ k -> U) (f : (x : A) (xs : |> k gStr A $ k) -> P (Cons x xs)) : (xs : gStr A $ k) -> P xs
  = split
     Cons x xs -> f x xs

ghd (A : U) k : (xs : gStr A $ k) -> A
  = split
     Cons x _ -> x

gtl (A : U) k : (xs : gStr A $ k) -> |> k (gStr A $ k)
  = split
     Cons _ xs -> xs

Str (A : U) : U
  = forall k, gStr A $ k

hd (A : U) (xs : Str A) : A
  = ghd A $ k0 (xs $ k0)

tl (A : U) (xs : Str A) : Str A
  = prev k (gtl A $ k (xs $ k))

data Unit = unit

units k : gStr Unit $ k
  = fix k units (gStr Unit $ k) (Cons unit units)

test2 : Unit
  = hd Unit (tl Unit (tl Unit units))

test3 : Str Unit
  = (tl Unit (tl Unit units))

data gCoNat k = zero | suc (n : |> k (gCoNat $ k))

CoNat : U
  = forall k, gCoNat $ k

data Maybe (A : U) = nothing | just (x : A)

case (A : U) k (z : A) (s : (|> k (gCoNat $ k)) -> A) : gCoNat $ k -> A
  = split
     zero -> z
     suc n -> s n

case' k (A : gCoNat $ k -> U) (z : A zero) (s : (n : |> k (gCoNat $ k)) -> A (suc n)) : (n : gCoNat $ k) -> A n
  = split
     zero -> z
     suc n -> s n

-- uncons (x : CoNat) k : Maybe CoNat
--   = case (Maybe CoNat) $ k nothing (\ (n : |> k (gCoNat $ k)) -> just ([ k' ] (suc ?))) (x $ k)

laterN k (n : |> k gCoNat $ k) (F : gCoNat $ k -> U) : U
  = |> k [ x <- n ] (F x) 

data gCoVec (A : U) k (n : gCoNat $ k) = con (_ : case U $ k Unit (\ (n : |> k (gCoNat $ k)) -> (_ : A ) * laterN $ k n (gCoVec A $ k)) n)

gCoVec' (A : U) k (n : gCoNat $ k) : U
  = case U $ k Unit (\ (n : |> k (gCoNat $ k)) -> (_ : A ) * laterN $ k n (gCoVec A $ k)) n


decon (A : U) k (n : gCoNat $ k) : gCoVec A $ k n -> gCoVec' A $ k n
 = split
    con x -> x

gtlv (A : U) k (n : |> k gCoNat $ k) : gCoVec A $ k (suc n) -> laterN $ k n (gCoVec A $ k)
  = split
      con x -> x.2

uncon (A : U) (B : U) k (n : gCoNat $ k) (f : case U $ k Unit (\ (n : |> k (gCoNat $ k)) -> (_ : A ) * laterN $ k n (gCoVec A $ k)) n -> B) :
    gCoVec A $ k n -> B
  = split
     con x -> f x


uncon' (A : U) k (n : gCoNat $ k) (B : gCoVec A $ k n -> U) (f : (v : gCoVec' A $ k n) -> B (con v)) :
    (v : gCoVec A $ k n) -> B v
  = split
     con x -> f x

-- data gCoVec' (A : U) k (n : gCoNat $ k) = nil (_ : IdP (<_> gCoNat $ k) n zero)
--                                       | cons (m : |> k gCoNat $ k) (x : A) (_ : IdP (<_> gCoNat $ k) (suc m) n)
--                                              (xs : |> k [ m' <- m ] gCoVec' A $ k m')

unitsv k : (n : gCoNat $ k) -> gCoVec Unit $ k n
  = fix k unitsv ((n : gCoNat $ k) -> gCoVec Unit $ k n)
        (case' $ k (gCoVec Unit $ k) (con unit)
            (\ (m : |> k (gCoNat $ k)) -> con (unit , next k [ f <- unitsv, x <- m] (f x) [])))


map (A B : U) (f : A -> B) k : (n : gCoNat $ k) -> gCoVec A $ k n -> gCoVec B $ k n
  = fix k map ((n : gCoNat $ k) -> gCoVec A $ k n -> gCoVec B $ k n)
        (case' $ k (\ (n : gCoNat $ k) -> gCoVec A $ k n -> gCoVec B $ k n) (\ (x : gCoVec A $ k zero) -> con unit)
                  (\ (n : |> k gCoNat $ k) -> uncon A (gCoVec B $ k (suc n)) $ k (suc n)
                        (\ (p : (_ : A) * laterN $ k n (gCoVec A $ k)) -> con (f (p.1) ,
                   next k [ map' <- map, n' <- n, xs <- p.2 ]
                          (map' n' xs) []))))


mapComp' (A B C : U) (f : A -> B) (g : B -> C) k (phi : |> k ((n : gCoNat $ k) (xs : gCoVec A $ k n) ->
        Id (gCoVec C $ k n) (map B C g $ k n (map A B f $ k n xs)) (map A C (\ (x : A) -> g (f x)) $ k n xs)))
      : (n : gCoNat $ k) (xs : gCoVec A $ k n) ->
        Id (gCoVec C $ k n) (map B C g $ k n (map A B f $ k n xs)) (map A C (\ (x : A) -> g (f x)) $ k n xs)
  = split
      zero -> \ (xs : gCoVec A $ k zero) -> <i> con unit
      suc n ->
        uncon' A $ k (suc n) (\ (xs : gCoVec A $ k (suc n)) ->
              Id (gCoVec C $ k (suc n)) (map B C g $ k (suc n) (map A B f $ k (suc n) xs)) (map A C (\ (x : A) -> g (f x)) $ k (suc n) xs))

            (\ (xs : gCoVec' A $ k (suc n)) -> <i> con (g (f xs.1) , next k
              [ phi' <- phi
              , n' <- n
              , xs' <- xs.2
              ]
               (phi' n' xs' @ i) [ (i=0) -> gtlv C $ k n (map B C g $ k (suc n) (map A B f $ k (suc n) (con xs)))
                                 , (i=1) -> gtlv C $ k n (map A C (\ (x : A) -> g (f x)) $ k (suc n) (con xs)) ]))

mapComp (A B C : U) (f : A -> B) (g : B -> C) k : (n : gCoNat $ k) (xs : gCoVec A $ k n) ->
        Id (gCoVec C $ k n) (map B C g $ k n (map A B f $ k n xs)) (map A C (\ (x : A) -> g (f x)) $ k n xs)
 = fix k mapComp 
       ((n : gCoNat $ k) (xs : gCoVec A $ k n) -> Id (gCoVec C $ k n) (map B C g $ k n (map A B f $ k n xs)) (map A C (\ (x : A) -> g (f x)) $ k n xs))
       (mapComp' A B C f g $ k mapComp)

data Nat = ze | su (n : Nat)

nats : Str Nat
  = [ k ] (fix k nats (Nat -> gStr Nat $ k) (\ (n : Nat) -> Cons n (next k [ nats' <- nats ] (nats' (su n)) []))) ze

everyother (A : U) (xs : Str A) : Str A
  = [ k ] (fix k everyother (Str A -> gStr A $ k) (\ (xs : Str A) -> 
             Cons (ghd A $ k (xs $ k)) (next k [ eo <- everyother ] (eo (tl A (tl A xs))) [])))
          xs


eoProp (A : U) (xs : Str A) : Id A (hd A (tl A (everyother A xs))) (hd A (tl A (tl A xs)))
  = <i> (hd A (tl A (tl A xs)))

-- (A : U Delta)
-- (A : U) (Support A Delta)
forallFresh (A : U) (t : forall k, A) k k' : Id A (t $ k) (t $ k')
  = <i> t $ k0

wrong k k' : Id U (gCoNat $ k) (gCoNat $ k')
  = forallFresh U gCoNat $ k $ k'

-- rightlyFails k k' : Id U (gCoNat $ k) (gCoNat $ k')
--   = <i> gCoNat $ k0

cze : CoNat
  = [ k ] zero

csu (n : CoNat) : CoNat
  = [ k ] (suc (next k (n $ k)))

data Bool = true | false

If (A B : U) : Bool -> U
  = split
      true -> A
      false -> B

if' (P : Bool -> U) (x : P true) (y : P false) : (b : Bool) -> P b
  = split
      true -> x
      false -> y

Plus (A B : U) : U
  = (b : Bool) * If A B b

comIf (A B : forall k, U) : (b : Bool) -> (forall k, If (A $ k) (B $ k) b) -> If (forall k, A $ k) (forall k, B $ k) b
  = split
      true -> \ (x : forall k, A $ k) -> x
      false -> \ (x : forall k, B $ k) -> x

comPlus' (A B : forall k, U) (z1 : forall k, Bool) (z2 : forall k, If (A $ k) (B $ k) (z1 $ k)) : Plus (forall k, A $ k) (forall k, B $ k)
 = ((z1 $ k0) , comIf A B (z1 $ k0) ([ k ] (z2 $ k)))

comPlus (A B : forall k, U) (z : forall k, Plus (A $ k) (B $ k)) : Plus (forall k, A $ k) (forall k, B $ k)
 = comPlus' A B ([ k ] (z $ k).1) ([ k ] (z $ k).2)

comCoNat' (n : CoNat) : Plus (forall k, Unit) (forall k, |> k gCoNat $ k)
  = comPlus ([ k ] Unit) ([ k ] |> k gCoNat $ k) ([ k ] case (Plus Unit (|> k gCoNat $ k)) $ k (true , unit) (\ (m : |> k gCoNat $ k) -> (false , m)) (n $ k))

comCoNat (n : CoNat) : Maybe CoNat
  = force q.1 q.2
   where
    q : Plus (forall k, Unit) (forall k, |> k gCoNat $ k)
      = comCoNat' n
    force : (b : Bool) -> If (forall k, Unit) (forall k, |> k gCoNat $ k) b -> Maybe CoNat
      = split
          true -> (\ (x : forall k, Unit) -> nothing)
          false -> (\ (x : forall k, |> k gCoNat $ k) -> just (prev k (x $ k)))

comcze : Id (Maybe CoNat) (comCoNat cze) nothing
  = <i> nothing

comcsu (n : CoNat) : Id (Maybe CoNat) (comCoNat (csu n)) (just n)
  = <i> just n

CoVec (A : U) (n : CoNat) : U
  = forall k, gCoVec A $ k (n $ k)

kcon (A : U) (n : CoNat) (xs : forall k, gCoVec' A $ k (n $ k)) : CoVec A n
  = [ k ] (con (xs $ k))

-- tlcv (A : U) (n : CoNat) (xs : CoVec A (csu n)) : CoVec A n
--   = kcon A n (prev k (app' (gCoVec A $ k (n $ k)) (gCoVec' A $ k (n $ k)) $ k (next k (decon A $ k (n $ k))) ((decon A $ k (csu n $ k) (xs $ k)).2)))

kmap (A B : U) (f : A -> B) (n : CoNat) (xs : CoVec A n) : CoVec B n
  = [ k ] map A B f $ k (n $ k) (xs $ k)

merge (A : U) k : (xs ys : gStr A $ k) -> gStr A $ k
  = fix k merge ((xs ys : gStr A $ k) -> gStr A $ k)
     (\ (xs ys : gStr A $ k) -> Cons (ghd A $ k xs)
             (next k [ phi' <- merge, xs' <- gtl A $ k xs ] (phi' ys xs') []))

expand (A : U) k : (xs : gStr A $ k) -> gStr A $ k
  = fix k expand (gStr A $ k -> gStr A $ k) (\ (xs : gStr A $ k) -> Cons (ghd A $ k xs) (next k [ phi' <- expand, xs' <- gtl A $ k xs ] (phi' xs') []))

etaStr (A : U) k : (xs : gStr A $ k) -> Id (gStr A $ k) (expand A $ k xs) xs
 = fix k etaStr ((xs : gStr A $ k) -> Id (gStr A $ k) (expand A $ k xs) xs)
         (uncons A $ k (\ (xs : gStr A $ k) -> Id (gStr A $ k) (expand A $ k xs) xs)
           (\ (x : A) (xs : |> k gStr A $ k) -> <i> Cons x (next k [ phi' <- etaStr, xs' <- xs ] (phi' xs' @ i)
                                                                   [ (i=0) -> gtl A $ k (expand A $ k (Cons x xs))
                                                                   , (i=1) -> gtl A $ k (Cons x xs) ])))

eomerge' (A : U) k : (xs ys : Str A) -> Id (gStr A $ k) (everyother A ([ k ] merge A $ k (xs $ k) (ys $ k)) $ k) (expand A $ k (xs $ k))
   = fix k eomerge' ((xs ys : Str A) -> Id (gStr A $ k) (everyother A ([ k ] merge A $ k (xs $ k) (ys $ k)) $ k) (expand A $ k (xs $ k)))
          (\ (xs ys : Str A) -> <i> Cons (ghd A $ k (xs $ k))
                                         (next k [ phi' <- eomerge' ] (phi' (tl A xs) (tl A ys) @ i)
                                          [ (i=0) -> gtl A $ k (everyother A ([ k ] merge A $ k (xs $ k) (ys $ k)) $ k)
                                          , (i=1) -> gtl A $ k (expand A $ k (xs $ k)) ]))

goemerge (A : U) k (xs ys : Str A) : Id (gStr A $ k) (everyother A ([ k ] merge A $ k (xs $ k) (ys $ k)) $ k) (xs $ k)
  = compId (gStr A $ k) (everyother A ([ k ] merge A $ k (xs $ k) (ys $ k)) $ k) (expand A $ k (xs $ k)) (xs $ k)
              (eomerge' A $ k xs ys) (etaStr A $ k (xs $ k))

oemerge (A : U) (xs ys : Str A) : Id (Str A) (everyother A ([ k ] merge A $ k (xs $ k) (ys $ k))) xs
  = <i> [ k ] goemerge A $ k xs ys @ i

-- tlcv (A : U) (n : CoNat) (xs : CoVec A (csu n)) : CoVec A n
--   = kcon A n (prev k (uncon A (|> k (gCoVec' A $ k (n $ k))) $ k (csu n $ k)
--              (\ (xs : gCoVec' A $ k (csu n $ k)) -> next k [ x <- xs.2 ] (decon A $ k (n $ k) x) [])
--              (xs $ k)))


zeros : Str Nat
  = [ k ] fix k zeros (gStr Nat $ k) (Cons ze zeros)

nth (A : U) (xs : Str A) : Nat -> A
 = split
     ze -> hd A xs
     su n -> nth A (tl A xs) n

isNth (A : U) (x : A) (xs : Str A) (n : Nat) : U
  = Id A (nth A xs n) x


hasZeros : (n : Nat) -> isNth Nat ze zeros n
 = split
     ze -> <i> ze
     su n -> hasZeros n

transportExample (n : Nat) : isNth Nat ze (everyother Nat ([ k ] merge Nat $ k (zeros $ k) (zeros $ k))) n
  = transport (<i> isNth Nat ze (oemerge Nat zeros zeros @ -i) n) (hasZeros n)

testComp : Id (Str Nat) zeros zeros
  = <i> comp (<_> Str Nat) (oemerge Nat zeros zeros @ -i)
               [ (i=1) -> oemerge Nat zeros zeros, (i=0) -> <_> zeros ]

testCompHead : Id Nat ze ze
  = <i> hd Nat (testComp @ i)
