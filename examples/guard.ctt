module guard where

next_sugar_test (A : U) (a : A) : |> A
  = next a

later (X : |> U) : U
  = |> [ (x : U) <- X ] x

F (A : U) (X : |> U) : U
 = (_  : A) * later X

head (A : U) (X : |> U) (x : F A X) : A
 = x.1
tail (A : U) (X : |> U) (x : F A X) : later X
 = x.2

cons (A : U) (X : |> U) (a : A) (x : later X) : F A X
 = (a , x)

foo (A : U) (t : |> A) : |> [ (x : A) <- t ] A
 = next [ (x : A) <- t ] x

foo' (A : U) (t : |> A) : |> [ (x : A) <- t ] A
 = t

-- fooeq (A : U) (t : |> A) : IdP (<i> |> A) (foo A t) (foo' A t)
--   = <i> t



bar (A : U) (t : |> A) (u : |> A) : |> [(x : A) <- t, (y : A) <- u] A
 = next [(x : A) <- t, (y : A) <- u] x

bar' (A : U) (t : |> A) (u : |> A) : |> [(x : A) <- t, (y : A) <- u] A
 = next [(y : A) <- u, (x : A) <- t] x
 
bar'' (A : U) (t : |> A) (u : |> A) : |> [(x : A) <- t, (y : A) <- u] A
 = t

bar''' (A : U) (t : |> A) (u : |> A) : |> [(x : A) <- t, (y : A) <- u] A
 = u

bareq (A : U) (t : |> A) (u : |> A) : IdP (<i> |> A) (bar A t u) (bar' A t u)
 = <i> (bar A t u)

baz (A : U) (B : A -> U) (t : |> A) (u : |> [(x : A) <- t] B x) : |> [(x : A) <- t, (y : B x) <- u] A
   = next [(x : A) <- t, (y : B x) <- u] x
-- = next [(y : B x) <- u, (x : A) <- t] x  -- this does not resolve (which is good)


data nat = zero | suc (n : nat)

app (A : U) (B : A -> U) (F : |> ((x : A) -> B x)) (T : |> A) : |> [ (t : A) <- T ] B t
  = next [ (f : ((x : A) -> B x)) <- F, (t : A) <- T ] f t


test_del_app_simple (A : U) (B : U) (f : |> (A -> B)) (a : |> A) : |> B
--  = next [ (f' : A -> B) <- f, (a' : A) <- a ] f' a'
  = app A (\ (_ : A) -> B) f a


test_dep_app2 (A : U) (B : A -> U) (f : |> ((x : A) -> B x)) (a : |> A) 
              (y : A) :
              |> [ (x : A) <- a] B x
 = app A B f a



test (A : U) (B : A -> U) (f : (a : A) -> B a) (a : A) : (x : |> A) -> |> [ (z : A) <- x ] B z
 = \ (x : |> A) -> next [ (y : A)  <- x ] (f y)

--test2 (A : U) (x : |> A) 


idL (A : U) : |> (A -> A)
  = next (\ (x : A) -> x)

-- idLisid (A : U) (a : A) : IdP (<i> |> A) (next [ (f : A -> A) <- idL A ] f a) (next a)
--   = <i> next a

-- test_force (A : U) (B : U) (t : A) (u : A -> B) : IdP (<i> |> B) (next [ (x : A) <- next t ] u x) (next (u t))
--  = <i> next (u t)

-- lemma :   IdP (<_> U) (|> U) (|> [ (x : U) <- next U ] x)
--   = <i> |> U

Str (A : U) : U
  = fix (U) (F A)

Strunfold (A : U) : IdP (<_> U) (|> Str A) (|> (x : A) * (Str A))
  = undefined

zeros : Str nat
  = fix (Str nat) (\ (x : |> Str nat) -> (zero , x))

{-
-- cast (f : (|> U) -> U) (x : |> fix U f) : |> (f (next (fix U f)))
--   = x

map (A : U) (B : U) (f : A -> B) : Str A -> Str B
  = fix (Str A -> Str B) (\ (x : |> (Str A -> Str B)) (as : Str A) ->
      ((f as.1) , (app (Str A) (\ (_ : Str A) -> Str B) x (as.2))))



ones : Str nat
  = map nat nat (\ (n : nat) -> suc n) zeros

recnat (A : U) (a : A) (f : A -> A) : nat -> A
  = split
      zero   -> a
      suc n  -> f (recnat A a f n)

iterate_suc : nat -> Str nat
  = fix (nat -> Str nat) (\ (f : |> (nat -> Str nat)) (n : nat) ->
      (n , f <*> (next (suc n))))

nats : Str nat
  = iterate_suc zero

iterate_suc_alt : nat -> Str nat
  = fix (nat -> Str nat) (\ (f : |> (nat -> Str nat)) (n : nat) ->
      (recnat nat zero (\ (m : nat) -> suc m) n
       , f <*> (next (suc n))))

nats' : Str nat
  = iterate_suc_alt zero

lemma : (n : nat) ->
  IdP (<i> nat) n (recnat nat zero (\ (m : nat) -> suc m) n)
  = split
      zero  -> <i> zero
      suc m -> <i> suc (lemma m @ i)


eqtest : IdP (<i> U) (Str nat) (Str nat)
 = <i> Str nat

eqtest' : IdP (<i> Str nat) nats nats
 = <i> nats

com (A : U) (t : A) (u : A) (p : |> (IdP (<i> A) t u)) : IdP (<i> |> A) (next t) (next u)
  = <i> (next [ (z : (IdP (<i> A) t u)) <- p ] (z @ i))

com' (A : U) (B : U) (AeqB : IdP (<i> U) A B) (t : A) (u : B)
     (p : |> (IdP AeqB t u))
     : IdP (<i> |> (AeqB @ i)) (next t) (next u)
  = <i> (next [ (z : IdP AeqB t u) <- p ] (z @ i))


-- p_eta from the paper
p_eta (A : U) (xs : Str A) (ys : Str A)
      (h : IdP (<i> A)         xs.1 ys.1)
      (t : IdP (<i> |> Str A)  xs.2 ys.2)
         : IdP (<i> Str A)     xs   ys
  = <i> (h @ i, t @ i)


nextzeros : |> Str nat
  = next zeros


-- this doesn't typecheck yet. See: unfoldOneFix in Eval.hs
later_zeroseq (p : |> (IdP (<i> Str nat) zeros zeros)) : IdP (<i> |> Str nat) (next zeros) (next zeros)
  = com (Str nat) zeros zeros p
-}
-- zeroseq' (p : |> (IdP (<i> Str nat) zeros zeros)) : IdP (<i> Str nat) zeros zeros
--   = <i> (zero , com (Str nat) zeros zeros p)

-- iterateeq' (p : |> ((n : nat) -> IdP (<i> Str nat) (iterate_suc n) (iterate_suc_alt n)))
--           (n : nat) : IdP (<i> Str nat) (iterate_suc n) (iterate_suc_alt n)
--   = ?
--   -- The following still doesn't typecheck.
--   -- = <i> (lemma n @ i , com (Str nat)
--   --                      	   (iterate_suc (suc n))
--   --                          (iterate_suc_alt (suc n))
--   -- 			   (p <*> (next (suc n))))

-- iterateeq : (n : nat) -> IdP (<i> Str nat) (iterate_suc n) (iterate_suc_alt n)
--   = fix ((n : nat) -> IdP (<i> Str nat) (iterate_suc n) (iterate_suc_alt n))
--         iterateeq'

           

-- natseq : IdP (<i> Str nat) nats nats'
--   = iterateeq zero